/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check server health status
         * @description Returns health information about the Dagu server
         */
        get: operations["getHealthStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Authenticate user and obtain JWT token
         * @description Authenticates a user with username and password, returns a JWT token on success
         */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current authenticated user
         * @description Returns information about the currently authenticated user
         */
        get: operations["getCurrentUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/change-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change current user's password
         * @description Allows the authenticated user to change their own password
         */
        post: operations["changePassword"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all users
         * @description Returns a list of all users. Requires admin role.
         */
        get: operations["listUsers"];
        put?: never;
        /**
         * Create a new user
         * @description Creates a new user account. Requires admin role.
         */
        post: operations["createUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user by ID
         * @description Returns a specific user by their ID. Requires admin role.
         */
        get: operations["getUser"];
        put?: never;
        post?: never;
        /**
         * Delete user
         * @description Deletes a user account. Requires admin role. Cannot delete yourself.
         */
        delete: operations["deleteUser"];
        options?: never;
        head?: never;
        /**
         * Update user
         * @description Updates a user's information. Requires admin role.
         */
        patch: operations["updateUser"];
        trace?: never;
    };
    "/users/{userId}/reset-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset user's password
         * @description Resets a user's password to a new value. Requires admin role.
         */
        post: operations["resetUserPassword"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api-keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all API keys
         * @description Returns all API keys. Requires admin role.
         */
        get: operations["listAPIKeys"];
        put?: never;
        /**
         * Create API key
         * @description Full key returned only in this response
         */
        post: operations["createAPIKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api-keys/{keyId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get API key
         * @description Returns API key by ID. Requires admin role.
         */
        get: operations["getAPIKey"];
        put?: never;
        post?: never;
        /**
         * Delete API key
         * @description Revokes an API key. Requires admin role.
         */
        delete: operations["deleteAPIKey"];
        options?: never;
        head?: never;
        /**
         * Update API key
         * @description Updates API key info. Requires admin role.
         */
        patch: operations["updateAPIKey"];
        trace?: never;
    };
    "/workers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List distributed workers
         * @description Retrieves information about distributed workers connected to the coordinator
         */
        get: operations["getWorkers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all available DAGs
         * @description Retrieves DAG definitions with optional filtering by name and tags
         */
        get: operations["listDAGs"];
        put?: never;
        /**
         * Create a new DAG definition
         * @description Creates a new empty DAG file with the specified name
         */
        post: operations["createNewDAG"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate a DAG specification
         * @description Validates a DAG YAML specification without persisting any changes.
         *
         *     Returns a list of validation errors. When the spec can be partially parsed,
         *     the response may also include parsed DAG details built with error-tolerant loading.
         *
         */
        post: operations["validateDAGSpec"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve comprehensive DAG information
         * @description Fetches detailed information about a specific DAG definition
         */
        get: operations["getDAGDetails"];
        put?: never;
        post?: never;
        /**
         * Delete an existing DAG
         * @description Permanently removes a DAG definition from the system
         */
        delete: operations["deleteDAG"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create and execute a DAG-run from DAG
         * @description Creates a DAG-run from the DAG definition and starts its execution with optional parameters
         */
        post: operations["executeDAG"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/start-sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute DAG synchronously and wait for completion
         * @description Creates a DAG-run from the DAG definition, starts its execution, waits for it to complete (or timeout), and returns the full execution details including node statuses.
         *
         *     **Important behaviors:**
         *     - If the timeout is exceeded, the DAG run continues executing in the background. The 408 response includes the `dagRunId` so clients can monitor or cancel the run.
         *     - If the DAG reaches a 'waiting' status (human-in-the-loop approval needed), the endpoint returns immediately with 200 and the current status.
         *
         */
        post: operations["executeDAGSync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/enqueue": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enqueue a DAG-run from DAG
         * @description Creates a DAG-run from the DAG definition and adds it to the queue for execution
         */
        post: operations["enqueueDAGDAGRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/dag-runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve execution history of a DAG
         * @description Fetches history of DAG-runs created from this DAG definition
         */
        get: operations["getDAGDAGRunHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/dag-runs/{dagRunId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get detailed status of a specific DAG-run
         * @description Retrieves status information about a particular DAG-run created from this DAG
         */
        get: operations["getDAGDAGRunDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/spec": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve DAG specification
         * @description Fetches the YAML specification of a DAG definition
         */
        get: operations["getDAGSpec"];
        /**
         * Update DAG spec
         * @description Modifies the YAML specification of a DAG definition
         */
        put: operations["updateDAGSpec"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/suspend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Toggle DAG suspension state
         * @description Controls whether the scheduler should create DAG-runs from this DAG according to its defined cron schedule
         */
        post: operations["updateDAGSuspensionState"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/rename": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change DAG file ID
         * @description Changes the file ID of the DAG definition
         */
        post: operations["renameDAG"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/stop-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop all running instances of a DAG
         * @description Terminates all currently running DAG-runs for the specified DAG
         */
        post: operations["stopAllDAGRuns"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search DAGs
         * @description Performs a full-text search across all DAG definitions
         */
        get: operations["searchDAGs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all available DAG tags
         * @description Retrieves all unique tags used across DAG definitions
         */
        get: operations["getAllDAGTags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all DAG-runs
         * @description Retrieves a list of all DAG-runs with optional filtering by name and status
         */
        get: operations["listDAGRuns"];
        put?: never;
        /**
         * Create and execute a DAG-run from inline spec
         * @description Creates a DAG-run directly from a provided DAG specification (YAML) and starts execution.
         *
         *     This endpoint does not require a pre-existing DAG file; the supplied `spec` is parsed and validated
         *     similarly to `/dags/validate`, and the run is executed immediately if valid.
         *
         */
        post: operations["executeDAGRunFromSpec"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/enqueue": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enqueue a DAG-run from inline spec
         * @description Creates a DAG-run directly from a provided DAG specification (YAML) and enqueues it for execution.
         *
         *     This endpoint does not require a pre-existing DAG file; the supplied `spec` is parsed and validated
         *     similarly to `/dags/validate`, and the run is persisted to the queue if valid.
         *
         */
        post: operations["enqueueDAGRunFromSpec"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all DAG-runs with a specific name
         * @description Retrieves a list of all DAG-runs with optional filtering by name and status
         */
        get: operations["listDAGRunsByName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve detailed status of a DAG-run
         * @description Fetches detailed status information about a specific DAG-run. Use 'latest' as the dagRunId to retrieve the most recent DAG-run for the specified DAG name.
         */
        get: operations["getDAGRunDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/spec": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve DAG specification for a DAG-run
         * @description Fetches the YAML specification of the DAG definition associated with this DAG-run
         */
        get: operations["getDAGRunSpec"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/reschedule": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reschedule DAG-run with a new run ID
         * @description Launch a fresh DAG-run from a historic execution while reusing its stored parameters.
         */
        post: operations["rescheduleDAGRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get sub DAG runs with timing info
         * @description Retrieves timing and status information for all sub DAG runs (including repeated executions) of a specific step. When parentSubDAGRunId is provided, returns sub-runs of that specific sub DAG run (for multi-level nested DAGs).
         */
        get: operations["getSubDAGRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/dequeue": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Dequeue a queued DAG-run
         * @description Dequeue a DAG-run execution that is currently queued
         */
        get: operations["dequeueDAGRun"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/log": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve full execution log of a DAG-run
         * @description Fetches the execution log for a DAG-run
         */
        get: operations["getDAGRunLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/log/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download full execution log of a DAG-run
         * @description Downloads the entire execution log file for a DAG-run
         */
        get: operations["downloadDAGRunLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/outputs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve collected outputs from a DAG-run
         * @description Fetches the outputs.json file containing all step outputs collected during the DAG-run execution. Returns the outputs as a JSON object where keys are the output names (converted from UPPER_CASE to camelCase by default, or custom key if specified) and values are the captured output strings.
         */
        get: operations["getDAGRunOutputs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retry DAG-run execution
         * @description Creates a new DAG-run based on a previous execution
         */
        post: operations["retryDAGRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Terminate a running DAG-run
         * @description Forcefully stops a running DAG-run created from this DAG
         */
        post: operations["terminateDAGRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/log": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve log for a specific step in a DAG-run
         * @description Fetches the log for an individual step in a DAG-run
         */
        get: operations["getDAGRunStepLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/log/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download log for a specific step in a DAG-run
         * @description Downloads the entire log file for an individual step in a DAG-run
         */
        get: operations["downloadDAGRunStepLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve chat messages for a step
         * @description Fetches the LLM chat message history for a chat step. Returns empty array for non-chat steps.
         */
        get: operations["getDAGRunStepMessages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Manually update a step's execution status
         * @description Changes the status of a specific step within a DAG-run
         */
        patch: operations["updateDAGRunStepStatus"];
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/approve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Approve a waiting step for HITL
         * @description Approves a step that is in Waiting status, optionally providing input parameters that will be available as environment variables in subsequent steps
         */
        post: operations["approveDAGRunStep"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/steps/{stepName}/reject": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reject a waiting step for HITL
         * @description Rejects a step that is in Waiting status, optionally providing a reason for rejection
         */
        post: operations["rejectDAGRunStep"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve detailed status of a sub DAG-run
         * @description Fetches detailed status information about a specific sub DAG-run
         */
        get: operations["getSubDAGRunDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/spec": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Sub-DAG Run Specification
         * @description Returns the YAML specification used for a specific sub-DAG run
         */
        get: operations["getSubDAGRunSpec"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/log": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve log for a specific sub DAG-run
         * @description Fetches the log for an individual sub DAG-run
         */
        get: operations["getSubDAGRunLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/log/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download log for a specific sub DAG-run
         * @description Downloads the entire log file for an individual sub DAG-run
         */
        get: operations["downloadSubDAGRunLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/log": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve log for a specific step in a sub DAG-run
         * @description Fetches the log for an individual step in a sub DAG-run
         */
        get: operations["getSubDAGRunStepLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/log/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download log for a specific step in a sub DAG-run
         * @description Downloads the entire log file for an individual step in a sub DAG-run
         */
        get: operations["downloadSubDAGRunStepLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve chat messages for a step in a sub DAG-run
         * @description Fetches the LLM chat message history for a chat step in a sub DAG-run. Returns empty array for non-chat steps.
         */
        get: operations["getSubDAGRunStepMessages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Manually update a step's execution status in a sub DAG-run
         * @description Changes the status of a specific step within a sub DAG-run
         */
        patch: operations["updateSubDAGRunStepStatus"];
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/approve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Approve a waiting step in a sub DAG-run for HITL
         * @description Approves a step that is in Waiting status within a sub DAG-run, optionally providing input parameters that will be available as environment variables in subsequent steps
         */
        post: operations["approveSubDAGRunStep"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dag-runs/{name}/{dagRunId}/sub-dag-runs/{subDAGRunId}/steps/{stepName}/reject": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reject a waiting step in a sub DAG-run for HITL
         * @description Rejects a step that is in Waiting status within a sub DAG-run, optionally providing a reason for rejection
         */
        post: operations["rejectSubDAGRunStep"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/queues": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all execution queues with summary statistics
         * @description Returns queue list with running/queued counts. Use /queues/{name}/items for paginated item details.
         */
        get: operations["listQueues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/queues/{name}/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get paginated items for a specific queue
         * @description Returns paginated list of running or queued DAG-runs for the specified queue
         */
        get: operations["listQueueItems"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/resources/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get resource usage history
         * @description Returns historical data for system resources
         */
        get: operations["getResourceHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/scheduler": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scheduler service status
         * @description Returns status information about all registered scheduler instances
         */
        get: operations["getSchedulerStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/coordinator": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get coordinator service status
         * @description Returns status information about all registered coordinator instances
         */
        get: operations["getCoordinatorStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/tunnel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tunnel service status
         * @description Returns status information about the tunnel service (Tailscale)
         */
        get: operations["getTunnelStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Prometheus metrics
         * @description Returns Prometheus-compatible metrics for monitoring Dagu operations
         */
        get: operations["getMetrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/{fileName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger DAG execution via webhook
         * @description Triggers a DAG execution via webhook. The DAG must have a webhook configured
         *     and enabled. Authentication is performed using a bearer token generated when
         *     the webhook was created (format: 'dagu_wh_...').
         *
         *     The request body is passed to the DAG as the WEBHOOK_PAYLOAD environment
         *     variable. The DAG run is enqueued and the endpoint returns immediately
         *     with the dag-run ID.
         *
         */
        post: operations["triggerWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all webhooks
         * @description Returns a list of all webhooks across all DAGs. Admin only.
         */
        get: operations["listWebhooks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/webhook": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get webhook for DAG
         * @description Returns the webhook configuration for a specific DAG, if one exists.
         */
        get: operations["getDAGWebhook"];
        put?: never;
        /**
         * Create webhook for DAG
         * @description Creates a new webhook for the specified DAG. Returns the full webhook token,
         *     which is only shown once. Store it securely.
         *
         */
        post: operations["createDAGWebhook"];
        /**
         * Delete webhook for DAG
         * @description Removes the webhook configuration for the specified DAG.
         */
        delete: operations["deleteDAGWebhook"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/webhook/regenerate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Regenerate webhook token
         * @description Generates a new token for the existing webhook. The old token becomes
         *     invalid immediately. Returns the new token, which is only shown once.
         *
         */
        post: operations["regenerateDAGWebhookToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{fileName}/webhook/toggle": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Toggle webhook enabled state
         * @description Enables or disables the webhook without changing the token.
         */
        post: operations["toggleDAGWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit log entries
         * @description Returns audit log entries matching the filter criteria. Admin only.
         */
        get: operations["listAuditLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Git sync status
         * @description Returns the overall Git sync status including status of all DAGs
         */
        get: operations["getSyncStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/pull": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Pull changes from remote repository
         * @description Fetches and syncs changes from the remote Git repository
         */
        post: operations["syncPull"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/publish-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Publish all modified DAGs
         * @description Commits and pushes all modified DAGs to the remote repository
         */
        post: operations["syncPublishAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/test-connection": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test connection to remote repository
         * @description Tests authentication and connectivity to the configured Git repository
         */
        post: operations["syncTestConnection"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Git sync configuration
         * @description Returns the current Git sync configuration
         */
        get: operations["getSyncConfig"];
        /**
         * Update Git sync configuration
         * @description Updates the Git sync configuration
         */
        put: operations["updateSyncConfig"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/dags/{name}/diff": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get diff for a DAG
         * @description Returns the diff between local and remote versions of a DAG
         */
        get: operations["getSyncDAGDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{name}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Publish a single DAG
         * @description Commits and pushes a single DAG to the remote repository
         */
        post: operations["publishDag"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dags/{name}/discard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Discard local changes for a DAG
         * @description Discards local changes and reverts to the version in the remote repository
         */
        post: operations["discardDagChanges"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description A single audit log entry */
        AuditEntry: {
            /** @description Unique identifier for this entry */
            id: string;
            /**
             * Format: date-time
             * @description When the event occurred
             */
            timestamp: string;
            /** @description Category of the audit event (e.g., terminal, user, dag) */
            category: string;
            /** @description The action that was performed (e.g., session_start, command, login) */
            action: string;
            /** @description ID of the user who performed the action */
            userId: string;
            /** @description Username of the user who performed the action */
            username: string;
            /** @description JSON-encoded action-specific details */
            details?: string;
            /** @description Client IP address if available */
            ipAddress?: string;
        };
        /** @description Response containing audit log entries */
        AuditLogsResponse: {
            /** @description List of audit log entries */
            entries: components["schemas"]["AuditEntry"][];
            /** @description Total number of entries matching the filter (before pagination) */
            total: number;
        };
        /** @description Request body for approving a waiting step */
        ApproveStepRequest: {
            /** @description Key-value parameters to provide. These will be available as environment variables in subsequent steps. */
            inputs?: {
                [key: string]: string;
            };
        };
        /** @description Response after approving a waiting step */
        ApproveStepResponse: {
            /** @description The DAG run ID */
            dagRunId: string;
            /** @description The approved step name */
            stepName: string;
            /** @description Whether the DAG run was re-enqueued for execution */
            resumed: boolean;
        };
        /** @description A single chat message in an LLM conversation */
        ChatMessage: {
            /**
             * @description Message role in the conversation
             * @enum {string}
             */
            role: ChatMessageRole;
            /** @description Message content */
            content: string;
            /** @description Tool calls made by the assistant (only for assistant messages) */
            toolCalls?: components["schemas"]["ChatToolCall"][];
            metadata?: components["schemas"]["ChatMessageMetadata"];
        };
        /** @description A tool call requested by the LLM */
        ChatToolCall: {
            /** @description Unique identifier for this tool call */
            id: string;
            /** @description Name of the tool being called */
            name: string;
            /** @description JSON string of tool arguments */
            arguments?: string;
        };
        /** @description Metadata about an LLM API call */
        ChatMessageMetadata: {
            /** @description LLM provider (openai, anthropic, gemini, etc.) */
            provider?: string;
            /** @description Model identifier used */
            model?: string;
            /** @description Number of tokens in the prompt */
            promptTokens?: number;
            /** @description Number of tokens in the completion */
            completionTokens?: number;
            /** @description Total tokens (prompt + completion) */
            totalTokens?: number;
        };
        /** @description Response containing chat messages for a step */
        ChatMessagesResponse: {
            /** @description List of chat messages */
            messages: components["schemas"]["ChatMessage"][];
            /** @description Tool definitions that were available to the LLM */
            toolDefinitions?: components["schemas"]["ToolDefinition"][];
            stepStatus: components["schemas"]["NodeStatus"];
            stepStatusLabel: components["schemas"]["NodeStatusLabel"];
            /** @description True if step is still running and more messages may arrive */
            hasMore: boolean;
        };
        /** @description A tool definition that was available to the LLM */
        ToolDefinition: {
            /** @description Name of the tool */
            name: string;
            /** @description Description of what the tool does */
            description?: string;
            /** @description JSON Schema describing the tool's parameters */
            parameters?: {
                [key: string]: unknown;
            };
        };
        /** @description Request body for rejecting a waiting step */
        RejectStepRequest: {
            /** @description Optional reason for rejecting the step */
            reason?: string;
        };
        /** @description Response after rejecting a waiting step */
        RejectStepResponse: {
            /** @description The DAG run ID */
            dagRunId: string;
            /** @description The rejected step name */
            stepName: string;
        };
        /** @description Generic error response object */
        Error: {
            code: components["schemas"]["ErrorCode"];
            /** @description Short error message */
            message: string;
            /** @description Additional error details */
            details?: Record<string, never>;
        };
        /** @description Timeout error response with DAG run tracking information */
        TimeoutError: components["schemas"]["Error"] & {
            dagRunId: components["schemas"]["DAGRunId"] & unknown;
        };
        /**
         * @description Error code indicating the type of error
         * @enum {string}
         */
        ErrorCode: ErrorCode;
        /** @description Request body for webhook trigger endpoint */
        WebhookRequest: {
            dagRunId?: components["schemas"]["DAGRunId"] & unknown;
            /** @description Arbitrary JSON payload to pass to the DAG as WEBHOOK_PAYLOAD */
            payload?: {
                [key: string]: unknown;
            };
        };
        /** @description Response from webhook trigger endpoint */
        WebhookResponse: {
            dagRunId: components["schemas"]["DAGRunId"];
            /** @description Name of the triggered DAG */
            dagName: string;
        };
        /** @description Webhook configuration details (token not included) */
        WebhookDetails: {
            /**
             * Format: uuid
             * @description Unique identifier for the webhook
             */
            id: string;
            /** @description Name of the DAG this webhook triggers */
            dagName: string;
            /** @description First 8 characters of the token for identification */
            tokenPrefix: string;
            /** @description Whether the webhook is active */
            enabled: boolean;
            /**
             * Format: date-time
             * @description When the webhook was created
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description When the webhook was last modified
             */
            updatedAt: string;
            /** @description User ID who created the webhook */
            createdBy?: string;
            /**
             * Format: date-time
             * @description When the webhook was last triggered
             */
            lastUsedAt?: string;
        };
        /** @description Response when creating or regenerating a webhook (includes full token) */
        WebhookCreateResponse: {
            webhook: components["schemas"]["WebhookDetails"];
            /** @description Full webhook token (only shown once, store securely!) */
            token: string;
        };
        /** @description List of all webhooks */
        WebhookListResponse: {
            webhooks: components["schemas"]["WebhookDetails"][];
        };
        /** @description Request to toggle webhook enabled state */
        WebhookToggleRequest: {
            /** @description Whether to enable or disable the webhook */
            enabled: boolean;
        };
        /**
         * Format: string
         * @enum {string}
         */
        Stream: Stream;
        /**
         * Format: int64
         * @description Unix timestamp in seconds
         * @example 1672531199
         */
        UnixTimestamp: number;
        /**
         * Format: regex
         * @description Name of the DAG file
         */
        DAGFileName: string;
        /**
         * Format: regex
         * @description Name of the DAG
         */
        DAGName: string;
        Pagination: {
            /** @description total number of records */
            totalRecords: number;
            /** @description current page number */
            currentPage: number;
            /** @description total number of pages */
            totalPages: number;
            /** @description next page number */
            nextPage: number;
            /** @description previous page number */
            prevPage: number;
        };
        /**
         * @description Unique identifier for the DAG-run. The special value 'latest' can be used to reference the most recent DAG-run.
         * @example latest
         */
        DAGRunId: string;
        /** @description Response object for the health check endpoint */
        HealthResponse: {
            /**
             * @description Overall health status of the server
             * @enum {string}
             */
            status: HealthResponseStatus;
            /** @description Current version of the server */
            version: string;
            /** @description Server uptime in seconds */
            uptime: number;
            /** @description Current server time */
            timestamp: string;
        };
        /** @description DAG file with its status information */
        DAGFile: {
            /** @description File ID of the DAG file */
            fileName: string;
            dag: components["schemas"]["DAG"];
            latestDAGRun: components["schemas"]["DAGRunSummary"];
            /** @description Whether the DAG is suspended */
            suspended: boolean;
            /** @description List of errors encountered during the request */
            errors: string[];
        };
        /** @description Core DAG configuration containing definition and metadata */
        DAG: {
            /** @description Logical grouping of related DAGs for organizational purposes */
            group?: string;
            /** @description Logical name of the DAG */
            name: string;
            /** @description List of scheduling expressions defining when DAG-runs should be created from this DAG */
            schedule?: components["schemas"]["Schedule"][];
            /** @description Human-readable description of the DAG's purpose and behavior */
            description?: string;
            /** @description List of parameter names that can be passed to DAG-runs created from this DAG */
            params?: string[];
            /** @description Default parameter values in JSON format if not specified at DAG-run creation */
            defaultParams?: string;
            /** @description List of tags for categorizing and filtering DAGs */
            tags?: string[];
            /** @description Name of the queue this DAG is assigned to. If not specified, the DAG name itself becomes the queue name */
            queue?: string;
            /**
             * @deprecated
             * @description DEPRECATED: This field is ignored for local (DAG-based) queues. For concurrency control, use global queues
             */
            maxActiveRuns?: number;
            runConfig?: components["schemas"]["RunConfig"];
        };
        /** @description Schedule configuration for DAG-run creation */
        Schedule: {
            /** @description Cron expression or schedule pattern */
            expression: string;
        };
        /**
         * @description Numeric status code indicating current DAG-run state:
         *     0: "Not started"
         *     1: "Running"
         *     2: "Failed"
         *     3: "Aborted"
         *     4: "Success"
         *     5: "Queued"
         *     6: "Partial Success"
         *     7: "Waiting for approval"
         *     8: "Rejected"
         *
         * @enum {integer}
         */
        Status: Status;
        /**
         * @description Human-readable status description for the DAG-run
         * @enum {string}
         */
        StatusLabel: StatusLabel;
        /**
         * @description How the DAG-run was initiated
         * @enum {string}
         */
        TriggerType: TriggerType;
        /**
         * @description Numeric status code indicating current node state:
         *     0: "Not started"
         *     1: "Running"
         *     2: "Failed"
         *     3: "Aborted"
         *     4: "Success"
         *     5: "Skipped"
         *     6: "Partial Success"
         *     7: "Waiting for approval"
         *     8: "Rejected"
         *
         * @enum {integer}
         */
        NodeStatus: NodeStatus;
        /**
         * @description Human-readable status description for the node
         * @enum {string}
         */
        NodeStatusLabel: NodeStatusLabel;
        /** @description Response containing status of all scheduler instances */
        SchedulerStatusResponse: {
            /** @description List of all registered scheduler instances */
            schedulers: components["schemas"]["SchedulerInstance"][];
        };
        /** @description Scheduler instance status information */
        SchedulerInstance: {
            /** @description Unique identifier of the scheduler instance */
            instanceId: string;
            /** @description Hostname where scheduler is running */
            host: string;
            /**
             * @description Scheduler status (active = holds lock and scheduling)
             * @enum {string}
             */
            status: SchedulerInstanceStatus;
            /** @description RFC3339 timestamp when scheduler started */
            startedAt: string;
        };
        /** @description Response containing status of all coordinator instances */
        CoordinatorStatusResponse: {
            /** @description List of all registered coordinator instances */
            coordinators: components["schemas"]["CoordinatorInstance"][];
        };
        /** @description Coordinator instance status information */
        CoordinatorInstance: {
            /** @description Unique identifier of the coordinator instance */
            instanceId: string;
            /** @description Hostname where coordinator is running */
            host: string;
            /**
             * @description Coordinator status
             * @enum {string}
             */
            status: CoordinatorInstanceStatus;
            /** @description RFC3339 timestamp when coordinator started */
            startedAt: string;
            /** @description Port number the coordinator is listening on */
            port: number;
        };
        /** @description Response containing tunnel service status */
        TunnelStatusResponse: {
            /** @description Whether tunneling is enabled in configuration */
            enabled: boolean;
            /**
             * @description The tunnel provider in use
             * @enum {string}
             */
            provider?: TunnelStatusResponseProvider;
            /**
             * @description Current status of the tunnel
             * @enum {string}
             */
            status: TunnelStatusResponseStatus;
            /**
             * Format: uri
             * @description The public URL provided by the tunnel
             */
            publicUrl?: string;
            /** @description Error message if tunnel failed */
            error?: string;
            /**
             * Format: date-time
             * @description RFC3339 timestamp when tunnel connected
             */
            startedAt?: string;
            /** @description Tunnel mode (e.g., 'direct' or 'funnel' for Tailscale) */
            mode?: string;
            /** @description Whether the tunnel provides public internet access */
            isPublic?: boolean;
        };
        /**
         * @description Health status of the worker based on heartbeat recency
         * @enum {string}
         */
        WorkerHealthStatus: WorkerHealthStatus;
        /** @description Detailed DAG configuration information */
        DAGDetails: {
            /** @description Logical grouping of related DAGs for organizational purposes */
            group?: string;
            /** @description Unique identifier for the DAG within its group */
            name: string;
            /** @description List of scheduling expressions defining when DAG-runs should be created from this DAG */
            schedule?: components["schemas"]["Schedule"][];
            /** @description Human-readable description of the DAG's purpose and behavior */
            description?: string;
            /** @description List of environment variables to set before executing a DAG-run */
            env?: string[];
            /** @description Directory path for storing log files */
            logDir?: string;
            handlerOn?: components["schemas"]["HandlerOn"];
            /** @description List of steps to execute in DAG-runs created from this DAG */
            steps?: components["schemas"]["Step"][];
            /** @description Time in seconds to wait before starting a DAG-run */
            delay?: number;
            /** @description Number of days to retain historical logs */
            histRetentionDays?: number;
            /** @description Conditions that must be met before a DAG-run can start */
            preconditions?: components["schemas"]["Condition"][];
            /**
             * @deprecated
             * @description DEPRECATED: This field is ignored for local (DAG-based) queues. For concurrency control, use global queues
             */
            maxActiveRuns?: number;
            /** @description Name of the queue this DAG is assigned to. If not specified, the DAG name itself becomes the queue name */
            queue?: string;
            /** @description Maximum number of concurrent steps allowed in a DAG run */
            maxActiveSteps?: number;
            /** @description List of parameter names that can be passed to DAG-runs created from this DAG */
            params?: string[];
            /** @description Default parameter values in JSON format if not specified at DAG-run creation */
            defaultParams?: string;
            /** @description List of tags for categorizing and filtering DAGs */
            tags?: string[];
            runConfig?: components["schemas"]["RunConfig"];
        };
        /** @description Configuration for controlling user interactions when starting DAG runs */
        RunConfig: {
            /**
             * @description Disable parameter editing when starting the DAG
             * @default false
             */
            disableParamEdit: boolean;
            /**
             * @description Disable custom run ID specification
             * @default false
             */
            disableRunIdEdit: boolean;
        };
        LocalDag: {
            /** @description Name of the local DAG */
            name: string;
            dag?: components["schemas"]["DAGDetails"];
            /** @description List of errors encountered while processing the local DAG */
            errors: string[];
        };
        /** @description Configuration for event handlers in a DAG-run */
        HandlerOn: {
            failure?: components["schemas"]["Step"];
            success?: components["schemas"]["Step"];
            cancel?: components["schemas"]["Step"];
            exit?: components["schemas"]["Step"];
        };
        /** @description Current status of a DAG-run */
        DAGRunSummary: {
            /** @description Name of the root DAG-run */
            rootDAGRunName: string;
            rootDAGRunId: components["schemas"]["DAGRunId"] & unknown;
            /** @description Name of the parent DAG-run */
            parentDAGRunName?: string;
            parentDAGRunId?: components["schemas"]["DAGRunId"] & unknown;
            dagRunId: components["schemas"]["DAGRunId"];
            name: components["schemas"]["DAGName"];
            status: components["schemas"]["Status"];
            statusLabel: components["schemas"]["StatusLabel"];
            /** @description RFC 3339 timestamp when the DAG-run was queued */
            queuedAt?: string;
            /** @description RFC 3339 timestamp when the DAG-run started */
            startedAt: string;
            /** @description RFC 3339 timestamp when the DAG-run finished */
            finishedAt: string;
            /** @description Path to the log file */
            log: string;
            /** @description Runtime parameters passed to the DAG-run in JSON format */
            params?: string;
            /** @description ID of the worker that executed this DAG-run ('local' for local execution) */
            workerId?: string;
            triggerType?: components["schemas"]["TriggerType"];
            /** @description List of tags for categorizing and filtering DAG runs */
            tags?: string[];
        };
        /** @description Detailed status of a DAG-run including sub DAG-run nodes */
        DAGRunDetails: components["schemas"]["DAGRunSummary"] & {
            /** @description Status of individual steps within the DAG-run */
            nodes: components["schemas"]["Node"][];
            onExit?: components["schemas"]["Node"];
            onSuccess?: components["schemas"]["Node"];
            onFailure?: components["schemas"]["Node"];
            onCancel?: components["schemas"]["Node"];
            /** @description List of preconditions that must be met before the DAG-run can start */
            preconditions?: components["schemas"]["Condition"][];
        };
        /** @description Collected outputs from step executions in a DAG-run, including execution metadata. If the DAG-run completed but no outputs were captured, the outputs object will be empty and metadata fields may be empty strings. */
        DAGRunOutputs: {
            metadata: components["schemas"]["OutputsMetadata"];
            /**
             * @description Collected step outputs as key-value pairs. Keys are output names (UPPER_CASE converted to camelCase by default, or custom key if specified) and values are the captured output strings. Empty object if no outputs were captured.
             * @example {
             *       "totalCount": "42",
             *       "resultFile": "/path/to/result.txt",
             *       "config": "{\"key\": \"value\"}"
             *     }
             */
            outputs: {
                [key: string]: string;
            };
        };
        /** @description Execution context metadata for the outputs */
        OutputsMetadata: {
            dagName: components["schemas"]["DAGName"];
            dagRunId: components["schemas"]["DAGRunId"];
            /** @description Attempt identifier within the run */
            attemptId: string;
            status: components["schemas"]["StatusLabel"];
            /**
             * Format: date-time
             * @description RFC3339 timestamp when execution completed
             */
            completedAt: string;
            /** @description JSON-serialized parameters passed to the DAG */
            params?: string;
        };
        /** @description Status of an individual step within a DAG-run */
        Node: {
            step: components["schemas"]["Step"];
            /** @description Path to the standard output log file for this step */
            stdout: string;
            /** @description Path to the standard error log file for this step */
            stderr: string;
            /** @description RFC3339 timestamp when the step started */
            startedAt: string;
            /** @description RFC3339 timestamp when the step finished */
            finishedAt: string;
            status: components["schemas"]["NodeStatus"];
            statusLabel: components["schemas"]["NodeStatusLabel"];
            /** @description Number of retry attempts made for this step */
            retryCount: number;
            /** @description Number of successful completions for repeating steps */
            doneCount: number;
            /** @description List of sub DAG-runs associated with this step */
            subRuns?: components["schemas"]["SubDAGRun"][];
            /** @description List of repeated sub DAG-runs when using repeatPolicy */
            subRunsRepeated?: components["schemas"]["SubDAGRun"][];
            /** @description Error message if the step failed */
            error?: string;
            /** @description RFC3339 timestamp when the HITL step was approved */
            approvedAt?: string;
            /** @description Username of who approved the HITL step */
            approvedBy?: string;
            /** @description Key-value inputs provided during HITL approval */
            approvalInputs?: {
                [key: string]: string;
            };
            /** @description RFC3339 timestamp when the HITL step was rejected */
            rejectedAt?: string;
            /** @description Username of who rejected the HITL step */
            rejectedBy?: string;
            /** @description Optional reason for rejection */
            rejectionReason?: string;
        };
        /** @description Metadata for a sub DAG-run */
        SubDAGRun: {
            dagRunId: components["schemas"]["DAGRunId"];
            /** @description Parameters passed to the sub DAG-run in JSON format */
            params?: string;
            /** @description Name of the executed sub-DAG. For chat tool calls, this is the tool DAG name. */
            dagName?: string;
        };
        /** @description Detailed information for a sub DAG-run including timing and status */
        SubDAGRunDetail: {
            dagRunId: components["schemas"]["DAGRunId"];
            /** @description Parameters passed to the sub DAG-run in JSON format */
            params?: string;
            /** @description Name of the executed sub-DAG. For chat tool calls, this is the tool DAG name. */
            dagName?: string;
            status: components["schemas"]["Status"];
            statusLabel: components["schemas"]["StatusLabel"];
            /** @description RFC 3339 timestamp when the sub DAG-run started */
            startedAt: string;
            /** @description RFC 3339 timestamp when the sub DAG-run finished */
            finishedAt?: string;
        };
        /** @description Individual task definition that performs a specific operation in a DAG-run */
        Step: {
            /** @description Unique identifier for the step within the DAG-run */
            name: string;
            /** @description Optional short identifier for the step. Can be used in variable references like ${id.stdout} to access step properties. Must be unique within the DAG if specified */
            id?: string;
            /** @description Human-readable description of what the step does */
            description?: string;
            /** @description Working directory for executing the step's command */
            dir?: string;
            /** @description List of commands to execute sequentially */
            commands?: components["schemas"]["CommandEntry"][];
            /** @description Script content if the step executes a script file */
            script?: string;
            /** @description File path for capturing standard output */
            stdout?: string;
            /** @description File path for capturing standard error */
            stderr?: string;
            /** @description Variable name to store the step's output */
            output?: string;
            /** @description The name of the DAG to execute as a sub DAG-run */
            call?: string;
            /** @description Parameters to pass to the sub DAG-run in JSON format */
            params?: string;
            /** @description Configuration for parallel execution of the step */
            parallel?: {
                /** @description Array of items to process in parallel. Can be a static array or a reference to a variable containing an array */
                items?: string[] | string;
                /** @description Maximum number of parallel executions. Default is 10 if not specified */
                maxConcurrent?: number;
            };
            /** @description List of step names that must complete before this step can start */
            depends?: string[];
            repeatPolicy?: components["schemas"]["RepeatPolicy"];
            /** @description Whether to send email notifications on step failure */
            mailOnError?: boolean;
            /** @description Conditions that must be met before the step can start */
            preconditions?: components["schemas"]["Condition"][];
            /** @description Maximum execution time for the step in seconds. If set, this timeout takes precedence over the DAG-level timeout for this step. */
            timeoutSec?: number;
            /** @description Executor configuration for this step */
            executorConfig?: {
                /** @description Type of executor (e.g., 'wait', 'http', 'docker', 'command') */
                type?: string;
                /** @description Executor-specific configuration */
                config?: {
                    [key: string]: unknown;
                };
            };
        };
        /** @description Individual search result item for a DAG */
        SearchResultItem: {
            /** @description Name of the matching DAG */
            name: string;
            dag: components["schemas"]["DAG"];
            /** @description Details of where matches were found */
            matches: components["schemas"]["SearchDAGsMatchItem"][];
        };
        /** @description Details of a search match within a DAG definition */
        SearchDAGsMatchItem: {
            /** @description Matching line content */
            line: string;
            /** @description Line number where match was found */
            lineNumber: number;
            /** @description Start line for context */
            startLine: number;
        };
        /** @description Log information for the execution */
        Log: {
            /** @description Log content */
            content: string;
            /** @description Number of lines returned */
            lineCount?: number;
            /** @description Total number of lines in the log file */
            totalLines?: number;
            /** @description Whether there are more lines available */
            hasMore?: boolean;
            /** @description Whether the line count is an estimate */
            isEstimate?: boolean;
        };
        /** @description Grid item for visualizing DAG-run execution history */
        DAGGridItem: {
            /** @description Name of the step */
            name: string;
            /** @description Status of the step ordered by time */
            history: components["schemas"]["NodeStatus"][];
        };
        /** @description Precondition that must be satisfied before running a step or DAG-run */
        Condition: {
            /** @description Expression or check to evaluate */
            condition: string;
            /** @description Expected result of the condition evaluation */
            expected?: string;
            /** @description If true, inverts the condition result (run when condition does NOT match) */
            negate?: boolean;
            /** @description Error message if the condition is not met */
            error?: string;
            /** @description Whether the condition was met */
            matched?: boolean;
        };
        /**
         * @description Repeat execution mode for steps
         * @enum {string}
         */
        RepeatMode: RepeatMode;
        /** @description Configuration for step repeat behavior */
        RepeatPolicy: {
            repeat?: components["schemas"]["RepeatMode"];
            /** @description Time in seconds to wait between repeat attempts */
            interval?: number;
            /** @description Maximum number of times to repeat the step */
            limit?: number;
            backoff?: boolean | number;
            /** @description Maximum interval in seconds (caps exponential growth) */
            maxIntervalSec?: number;
            condition?: components["schemas"]["Condition"];
            /** @description List of exit codes that trigger repeat behavior */
            exitCode?: number[];
        };
        /** @description A command with its arguments */
        CommandEntry: {
            /** @description The command to execute */
            command: string;
            /** @description Arguments for the command */
            args?: string[];
        };
        /** @description Response object for listing all tags */
        ListTagResponse: {
            /** @description List of unique tags */
            tags: string[];
            /** @description List of errors encountered during the request */
            errors: string[];
        };
        /** @description Response object for listing distributed workers */
        WorkersListResponse: {
            /** @description List of distributed workers */
            workers: components["schemas"]["Worker"][];
            /** @description List of errors encountered during the request */
            errors: string[];
        };
        /** @description Information about a distributed worker */
        Worker: {
            /** @description Unique identifier for the worker */
            id: string;
            /** @description Key-value pairs of labels assigned to the worker */
            labels: {
                [key: string]: string;
            };
            /** @description Total number of pollers configured for this worker */
            totalPollers: number;
            /** @description Number of pollers currently executing tasks */
            busyPollers: number;
            /** @description List of tasks currently being executed by this worker */
            runningTasks: components["schemas"]["RunningTask"][];
            /** @description RFC3339 timestamp of the last heartbeat received from this worker */
            lastHeartbeatAt: string;
            healthStatus: components["schemas"]["WorkerHealthStatus"];
        };
        /** @description Information about a task currently being executed */
        RunningTask: {
            dagRunId: components["schemas"]["DAGRunId"];
            dagName: components["schemas"]["DAGName"];
            /** @description RFC3339 timestamp when the task started */
            startedAt: string;
            rootDagRunName?: components["schemas"]["DAGName"];
            rootDagRunId?: components["schemas"]["DAGRunId"];
            parentDagRunName?: components["schemas"]["DAGName"];
            parentDagRunId?: components["schemas"]["DAGRunId"];
        };
        /** @description Response containing all queues with their active DAG-runs */
        QueuesResponse: {
            /** @description List of all queues with their running and queued DAG-runs */
            queues: components["schemas"]["Queue"][];
            summary: components["schemas"]["QueuesSummary"];
        };
        /** @description A queue/process group with summary statistics */
        Queue: {
            /** @description Name of the queue (global queue name or DAG name if no queue specified) */
            name: string;
            /**
             * @description Type of queue - 'global' if explicitly defined, 'dag-based' if using DAG name
             * @enum {string}
             */
            type: QueueType;
            /** @description Maximum number of concurrent runs allowed. For 'global' queues, this is the configured maxConcurrency. For 'dag-based' queues, this is always 1 (FIFO execution) */
            maxConcurrency?: number;
            /** @description Number of currently running DAG-runs */
            runningCount: number;
            /** @description Number of queued DAG-runs waiting to execute */
            queuedCount: number;
            /** @description List of currently running DAG-runs (bounded by maxConcurrency) */
            running: components["schemas"]["DAGRunSummary"][];
        };
        /** @description Paginated queue items response */
        QueueItemsResponse: {
            /** @description List of DAG-run summaries */
            items: components["schemas"]["DAGRunSummary"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** @description Summary statistics across all queues */
        QueuesSummary: {
            /** @description Total number of active queues */
            totalQueues: number;
            /** @description Total DAG-runs currently executing */
            totalRunning: number;
            /** @description Total DAG-runs waiting in queues */
            totalQueued: number;
            /** @description Sum of all queue maxConcurrency values */
            totalCapacity: number;
            /**
             * Format: float
             * @description System-wide utilization (totalRunning / totalCapacity * 100)
             */
            utilizationPercentage: number;
        };
        ResourceHistory: {
            cpu?: components["schemas"]["MetricPoint"][];
            memory?: components["schemas"]["MetricPoint"][];
            disk?: components["schemas"]["MetricPoint"][];
            load?: components["schemas"]["MetricPoint"][];
        };
        MetricPoint: {
            /**
             * Format: int64
             * @description Unix timestamp
             */
            timestamp: number;
            /** Format: double */
            value: number;
        };
        /**
         * @description User role determining access permissions. admin: full access including user management, manager: DAG CRUD and execution, operator: DAG execution only, viewer: read-only
         * @enum {string}
         */
        UserRole: UserRole;
        /** @description Request body for user login */
        LoginRequest: {
            /** @description User's username */
            username: string;
            /** @description User's password */
            password: string;
        };
        /** @description Response containing authentication token */
        LoginResponse: {
            /** @description JWT authentication token */
            token: string;
            /**
             * Format: date-time
             * @description Token expiration timestamp
             */
            expiresAt: string;
            user: components["schemas"]["User"];
        };
        /** @description Request body for changing password */
        ChangePasswordRequest: {
            /** @description Current password for verification */
            currentPassword: string;
            /** @description New password to set */
            newPassword: string;
        };
        /** @description Request body for admin password reset */
        ResetPasswordRequest: {
            /** @description New password to set for the user */
            newPassword: string;
        };
        /** @description Request body for creating a new user */
        CreateUserRequest: {
            /** @description Unique username */
            username: string;
            /** @description User's password */
            password: string;
            role: components["schemas"]["UserRole"];
        };
        /** @description Request body for updating a user */
        UpdateUserRequest: {
            /** @description New username (must be unique) */
            username?: string;
            role?: components["schemas"]["UserRole"];
            /** @description Whether to disable the user account */
            isDisabled?: boolean;
        };
        /** @description User information */
        User: {
            /** @description Unique user identifier */
            id: string;
            /** @description User's username */
            username: string;
            role: components["schemas"]["UserRole"];
            /**
             * @description Authentication provider (builtin or oidc)
             * @enum {string}
             */
            authProvider?: UserAuthProvider;
            /** @description Whether the user account is disabled */
            isDisabled?: boolean;
            /**
             * Format: date-time
             * @description Account creation timestamp
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description Last update timestamp
             */
            updatedAt: string;
        };
        /** @description Response containing user information */
        UserResponse: {
            user: components["schemas"]["User"];
        };
        /** @description Response containing list of users */
        UsersListResponse: {
            users: components["schemas"]["User"][];
        };
        /** @description API key information */
        APIKey: {
            /** @description Unique identifier */
            id: string;
            /** @description Human-readable name */
            name: string;
            /** @description Purpose description */
            description?: string;
            role: components["schemas"]["UserRole"];
            /** @description First 8 characters for identification */
            keyPrefix: string;
            /**
             * Format: date-time
             * @description Creation timestamp
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description Last update timestamp
             */
            updatedAt: string;
            /** @description Creator user ID */
            createdBy: string;
            /**
             * Format: date-time
             * @description Last authentication timestamp
             */
            lastUsedAt?: string | null;
        };
        /** @description API key response */
        APIKeyResponse: {
            apiKey: components["schemas"]["APIKey"];
        };
        /** @description List of API keys */
        APIKeysListResponse: {
            apiKeys: components["schemas"]["APIKey"][];
        };
        /** @description Create API key request */
        CreateAPIKeyRequest: {
            /** @description Human-readable name */
            name: string;
            /** @description Purpose description */
            description?: string;
            role: components["schemas"]["UserRole"];
        };
        /** @description Create API key response */
        CreateAPIKeyResponse: {
            apiKey: components["schemas"]["APIKey"];
            /** @description Full key secret, only returned once */
            key: string;
        };
        /** @description Update API key request */
        UpdateAPIKeyRequest: {
            /** @description New name */
            name?: string;
            /** @description New description */
            description?: string;
            role?: components["schemas"]["UserRole"];
        };
        /** @description Generic success response */
        SuccessResponse: {
            /** @description Success message */
            message: string;
        };
        /**
         * @description Sync status of a DAG
         * @enum {string}
         */
        SyncStatus: SyncStatus;
        /**
         * @description Summary status for the sync badge
         * @enum {string}
         */
        SyncSummary: SyncSummary;
        /** @description Sync state for a single DAG */
        SyncDAGState: {
            status: components["schemas"]["SyncStatus"];
            /** @description Commit hash when last synced */
            baseCommit?: string;
            /** @description Content hash when last synced */
            lastSyncedHash?: string;
            /**
             * Format: date-time
             * @description When the DAG was last synced
             */
            lastSyncedAt?: string;
            /**
             * Format: date-time
             * @description When the DAG was last modified locally
             */
            modifiedAt?: string;
            /** @description Current local content hash */
            localHash?: string;
            /** @description Remote commit hash (for conflicts) */
            remoteCommit?: string;
            /** @description Author of the remote commit (for conflicts) */
            remoteAuthor?: string;
            /** @description Message of the remote commit (for conflicts) */
            remoteMessage?: string;
            /**
             * Format: date-time
             * @description When the conflict was detected
             */
            conflictDetectedAt?: string;
        };
        /** @description Counts of DAGs in each sync status */
        SyncStatusCounts: {
            synced: number;
            modified: number;
            untracked: number;
            conflict: number;
        };
        /** @description Overall Git sync status */
        SyncStatusResponse: {
            /** @description Whether Git sync is enabled */
            enabled: boolean;
            /** @description Repository URL */
            repository?: string;
            /** @description Branch being synced */
            branch?: string;
            summary: components["schemas"]["SyncSummary"];
            /**
             * Format: date-time
             * @description When the last sync occurred
             */
            lastSyncAt?: string;
            /** @description Commit hash of last sync */
            lastSyncCommit?: string;
            /** @description Status of last sync (success/error) */
            lastSyncStatus?: string;
            /** @description Error message from last failed sync */
            lastError?: string;
            /** @description Sync state for each DAG */
            dags?: {
                [key: string]: components["schemas"]["SyncDAGState"];
            };
            counts: components["schemas"]["SyncStatusCounts"];
        };
        /** @description Error during sync operation */
        SyncError: {
            dagId?: string;
            message: string;
        };
        /** @description Diff between local and remote versions of a DAG */
        SyncDAGDiffResponse: {
            /** @description The DAG identifier */
            dagId: string;
            status: components["schemas"]["SyncStatus"];
            /** @description Current local file content */
            localContent: string;
            /** @description Content from remote repository */
            remoteContent?: string;
            /** @description Commit hash being compared against */
            remoteCommit?: string;
            /** @description Author of the remote commit */
            remoteAuthor?: string;
            /** @description Commit message of the remote version */
            remoteMessage?: string;
        };
        /** @description Result of a sync operation */
        SyncResultResponse: {
            success: boolean;
            message?: string;
            /** @description DAG IDs that were synced */
            synced?: string[];
            /** @description DAG IDs that were modified */
            modified?: string[];
            /** @description DAG IDs with conflicts */
            conflicts?: string[];
            errors?: components["schemas"]["SyncError"][];
            /** Format: date-time */
            timestamp: string;
        };
        /** @description Request to publish a DAG */
        SyncPublishRequest: {
            /** @description Commit message */
            message?: string;
            /**
             * @description Force publish even with conflicts
             * @default false
             */
            force: boolean;
        };
        /** @description Request to publish all modified DAGs */
        SyncPublishAllRequest: {
            /** @description Commit message */
            message?: string;
        };
        /** @description Response when a conflict is detected */
        SyncConflictResponse: {
            dagId: string;
            remoteCommit?: string;
            remoteAuthor?: string;
            remoteMessage?: string;
            message: string;
        };
        /** @description Result of connection test */
        SyncConnectionTestResponse: {
            success: boolean;
            message?: string;
            error?: string;
        };
        /** @description Git authentication configuration */
        SyncAuthConfig: {
            /** @enum {string} */
            type: SyncAuthConfigType;
            /** @description Personal access token (write-only) */
            token?: string;
            /** @description Path to SSH private key */
            sshKeyPath?: string;
        };
        /** @description Auto-sync configuration */
        SyncAutoSyncConfig: {
            enabled: boolean;
            onStartup: boolean;
            /** @description Sync interval in seconds */
            interval: number;
        };
        /** @description Commit configuration */
        SyncCommitConfig: {
            authorName?: string;
            authorEmail?: string;
        };
        /** @description Git sync configuration */
        SyncConfigResponse: {
            enabled: boolean;
            repository?: string;
            branch?: string;
            path?: string;
            auth?: components["schemas"]["SyncAuthConfig"];
            autoSync?: components["schemas"]["SyncAutoSyncConfig"];
            pushEnabled?: boolean;
            commit?: components["schemas"]["SyncCommitConfig"];
        };
        /** @description Request to update Git sync configuration */
        SyncConfigUpdateRequest: {
            enabled?: boolean;
            repository?: string;
            branch?: string;
            path?: string;
            auth?: components["schemas"]["SyncAuthConfig"];
            autoSync?: components["schemas"]["SyncAutoSyncConfig"];
            pushEnabled?: boolean;
            commit?: components["schemas"]["SyncCommitConfig"];
        };
    };
    responses: never;
    parameters: {
        /** @description page number of items to fetch (default is 1) */
        Page: number;
        /** @description unique identifier of the user */
        UserId: string;
        /** @description unique identifier of the API key */
        APIKeyId: string;
        /** @description number of items per page (default is 30, max is 100) */
        PerPage: number;
        /** @description the name of the DAG file */
        DAGFileName: components["schemas"]["DAGFileName"];
        /** @description name of the DAG */
        DAGName: components["schemas"]["DAGName"];
        /** @description name of the step */
        StepName: string;
        /** @description name of the remote node */
        RemoteNode: string;
        /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
        DAGRunId: components["schemas"]["DAGRunId"];
        /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
        DAGRunIdSearch: components["schemas"]["DAGRunId"];
        /** @description name of the DAG-run */
        DAGRunName: string;
        /** @description status of the DAG-run */
        Status: components["schemas"]["Status"];
        /** @description start datetime for filtering DAG-runs in ISO 8601 format with timezone */
        DateTimeFrom: components["schemas"]["UnixTimestamp"];
        /** @description end datetime for filtering DAG-runs in ISO 8601 format with timezone */
        DateTimeTo: components["schemas"]["UnixTimestamp"];
        /** @description Number of lines to return from the end of the file */
        Tail: number;
        /** @description Number of lines to return from the beginning of the file */
        Head: number;
        /** @description Line number to start reading from (1-based) */
        Offset: number;
        /** @description Maximum number of lines to return */
        Limit: number;
        /** @description Whether to return stdout or stderr logs */
        Stream: components["schemas"]["Stream"];
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getHealthStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginRequest"];
            };
        };
        responses: {
            /** @description Authentication successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoginResponse"];
                };
            };
            /** @description Invalid credentials */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getCurrentUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Current user information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    changePassword: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChangePasswordRequest"];
            };
        };
        responses: {
            /** @description Password changed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessResponse"];
                };
            };
            /** @description Invalid request (e.g., weak password) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated or wrong current password */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listUsers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UsersListResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateUserRequest"];
            };
        };
        responses: {
            /** @description User created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Invalid request (e.g., weak password, invalid role) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict - username already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the user */
                userId: components["parameters"]["UserId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the user */
                userId: components["parameters"]["UserId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role or cannot delete self */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the user */
                userId: components["parameters"]["UserId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateUserRequest"];
            };
        };
        responses: {
            /** @description User updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict - username already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    resetUserPassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the user */
                userId: components["parameters"]["UserId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ResetPasswordRequest"];
            };
        };
        responses: {
            /** @description Password reset successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessResponse"];
                };
            };
            /** @description Invalid request (e.g., weak password) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listAPIKeys: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of API keys */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIKeysListResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateAPIKeyRequest"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateAPIKeyResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Name already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the API key */
                keyId: components["parameters"]["APIKeyId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API key details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIKeyResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the API key */
                keyId: components["parameters"]["APIKeyId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API key deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description unique identifier of the API key */
                keyId: components["parameters"]["APIKeyId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateAPIKeyRequest"];
            };
        };
        responses: {
            /** @description Updated API key */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIKeyResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Name already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getWorkers: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkersListResponse"];
                };
            };
            /** @description Coordinator service unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDAGs: {
        parameters: {
            query?: {
                /** @description page number of items to fetch (default is 1) */
                page?: components["parameters"]["Page"];
                /** @description number of items per page (default is 30, max is 100) */
                perPage?: components["parameters"]["PerPage"];
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Filter DAGs by name */
                name?: string;
                /** @description Filter DAGs by tags (comma-separated). Returns DAGs that have ALL specified tags. */
                tags?: string;
                /** @description Field to sort by:
                 *     - `name`: Sort alphabetically by DAG name (case-insensitive)
                 *     - `nextRun`: Sort by next scheduled run time. DAGs with earlier next run times appear first in ascending order. DAGs without schedules appear last.
                 *      */
                sort?: PathsDagsGetParametersQuerySort;
                /** @description Sort order (ascending or descending) */
                order?: PathsDagsGetParametersQueryOrder;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of DAG definitions with their status and metadata */
                        dags: components["schemas"]["DAGFile"][];
                        /** @description List of errors encountered during the request */
                        errors: string[];
                        pagination: components["schemas"]["Pagination"];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createNewDAG: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    name: components["schemas"]["DAGName"];
                    /** @description Optional DAG spec in YAML format to initialize the DAG. If provided, the spec will be validated before creation. */
                    spec?: string;
                };
            };
        };
        responses: {
            /** @description A successful response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Name of the newly created DAG */
                        name: string;
                    };
                };
            };
            /** @description Invalid DAG spec */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    validateDAGSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description DAG specification in YAML format */
                    spec: string;
                    /** @description Optional name to use when the spec omits a name */
                    name?: string;
                };
            };
        };
        responses: {
            /** @description Validation result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description True if the spec is valid (no errors) */
                        valid: boolean;
                        dag?: components["schemas"]["DAGDetails"];
                        /** @description List of validation errors */
                        errors: string[];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGDetails: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dag?: components["schemas"]["DAGDetails"];
                        /** @description List of local DAGs that are part of this DAG */
                        localDags: components["schemas"]["LocalDag"][];
                        latestDAGRun: components["schemas"]["DAGRunDetails"];
                        /** @description Whether the DAG is suspended */
                        suspended: boolean;
                        /** @description List of errors encountered during the request */
                        errors: string[];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteDAG: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description DAG successfully deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    executeDAG: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Parameters to pass to the DAG-run in JSON format */
                    params?: string;
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Optional DAG name override to use for the created dag-run */
                    dagName?: string;
                    /**
                     * @description If true, prevent starting if DAG is already running (returns 409 conflict)
                     * @default false
                     */
                    singleton?: boolean;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunId: components["schemas"]["DAGRunId"];
                    };
                };
            };
            /** @description DAG is already running (singleton mode) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    executeDAGSync: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Parameters to pass to the DAG-run in JSON format */
                    params?: string;
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Optional DAG name override to use for the created dag-run */
                    dagName?: string;
                    /**
                     * @description If true, prevent starting if DAG is already running (returns 409 conflict)
                     * @default false
                     */
                    singleton?: boolean;
                    /** @description Maximum seconds to wait for DAG execution to complete (required) */
                    timeout: number;
                };
            };
        };
        responses: {
            /** @description DAG-run completed (or reached waiting status) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRun: components["schemas"]["DAGRunDetails"];
                    };
                };
            };
            /** @description Timeout waiting for DAG execution to complete. The DAG run continues executing in the background. */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TimeoutError"];
                };
            };
            /** @description DAG is already running (singleton mode) or dagRunId already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    enqueueDAGDAGRun: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Parameters to pass to the DAG-run in JSON format */
                    params?: string;
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Optional DAG name override to use for the queued dag-run */
                    dagName?: string;
                    /** @description Override the DAG-level queue definition */
                    queue?: string;
                    /**
                     * @description If true, prevent enqueuing if DAG is already running or queued (returns 409 conflict)
                     * @default false
                     */
                    singleton?: boolean;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunId: components["schemas"]["DAGRunId"];
                    };
                };
            };
            /** @description DAG is already running or queued (singleton mode) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGDAGRunHistory: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of historical DAG-runs created from this DAG */
                        dagRuns: components["schemas"]["DAGRunDetails"][];
                        /** @description Grid data for visualization */
                        gridData: components["schemas"]["DAGGridItem"][];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGDAGRunDetails: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRun: components["schemas"]["DAGRunDetails"];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dag?: components["schemas"]["DAGDetails"];
                        /** @description The DAG spec in YAML format */
                        spec: string;
                        /** @description List of errors in the spec */
                        errors: string[];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDAGSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The new DAG spec in YAML format */
                    spec: string;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of errors in the spec */
                        errors: string[];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDAGSuspensionState: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Suspend status to set for the DAG */
                    suspend: boolean;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    renameDAG: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description New file name for the DAG */
                    newFileName: string;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    stopAllDAGRuns: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully stopped all running instances */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Errors encountered */
                        errors: string[];
                    };
                };
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    searchDAGs: {
        parameters: {
            query: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description A search query string */
                q: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Search results matching the query */
                        results: components["schemas"]["SearchResultItem"][];
                        /** @description Errors encountered during the search */
                        errors: string[];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getAllDAGTags: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListTagResponse"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDAGRuns: {
        parameters: {
            query?: {
                /** @description status of the DAG-run */
                status?: components["parameters"]["Status"];
                /** @description start datetime for filtering DAG-runs in ISO 8601 format with timezone */
                fromDate?: components["parameters"]["DateTimeFrom"];
                /** @description end datetime for filtering DAG-runs in ISO 8601 format with timezone */
                toDate?: components["parameters"]["DateTimeTo"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId?: components["parameters"]["DAGRunIdSearch"];
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Filter DAG-runs by name */
                name?: string;
                /** @description Filter DAG-runs by DAG tags (comma-separated). Returns runs from DAGs that have ALL specified tags. */
                tags?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of DAG-runs with their status and metadata */
                        dagRuns: components["schemas"]["DAGRunSummary"][];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    executeDAGRunFromSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description DAG specification in YAML format */
                    spec: string;
                    /** @description Optional name to use when the spec omits a name */
                    name?: string;
                    /** @description Parameters to pass to the DAG-run in JSON format */
                    params?: string;
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /**
                     * @description If true, prevent starting if a DAG with the same name is already running (returns 409)
                     * @default false
                     */
                    singleton?: boolean;
                };
            };
        };
        responses: {
            /** @description Run created and started */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunId: components["schemas"]["DAGRunId"];
                    };
                };
            };
            /** @description Invalid DAG spec or parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description A DAG with the same name is already running and singleton is enabled */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    enqueueDAGRunFromSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description DAG specification in YAML format */
                    spec: string;
                    /** @description Optional name to use when the spec omits a name */
                    name?: string;
                    /** @description Parameters to persist with the queued DAG-run in JSON format */
                    params?: string;
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Override the queue to use for this DAG-run */
                    queue?: string;
                };
            };
        };
        responses: {
            /** @description DAG-run successfully enqueued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunId: components["schemas"]["DAGRunId"];
                    };
                };
            };
            /** @description Invalid DAG spec or parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description A DAG with the same name is already queued beyond maxActiveRuns */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDAGRunsByName: {
        parameters: {
            query?: {
                /** @description status of the DAG-run */
                status?: components["parameters"]["Status"];
                /** @description start datetime for filtering DAG-runs in ISO 8601 format with timezone */
                fromDate?: components["parameters"]["DateTimeFrom"];
                /** @description end datetime for filtering DAG-runs in ISO 8601 format with timezone */
                toDate?: components["parameters"]["DateTimeTo"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId?: components["parameters"]["DAGRunIdSearch"];
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG-run */
                name: components["parameters"]["DAGRunName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of DAG-runs with their status and metadata */
                        dagRuns: components["schemas"]["DAGRunSummary"][];
                    };
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunDetails: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunDetails: components["schemas"]["DAGRunDetails"];
                    };
                };
            };
            /** @description DAGRun not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The DAG spec in YAML format */
                        spec: string;
                    };
                };
            };
            /** @description DAG-run or DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    rescheduleDAGRun: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    dagRunId?: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Optional DAG name override for the new run. */
                    dagName?: string;
                };
            };
        };
        responses: {
            /** @description Successfully scheduled a new DAG-run */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunId: components["schemas"]["DAGRunId"];
                        /** @description Indicates whether the run was queued instead of starting immediately. */
                        queued: boolean;
                    };
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Historic run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict (run ID already exists or concurrency guard blocks execution) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRuns: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Optional parent sub DAG run ID. When provided, returns sub-runs of this specific sub DAG run instead of the root DAG run. Used for multi-level nested DAGs. */
                parentSubDAGRunId?: string;
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subRuns: components["schemas"]["SubDAGRunDetail"][];
                    };
                };
            };
            /** @description DAG run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    dequeueDAGRun: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description DAGRun not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Number of lines to return from the end of the file */
                tail?: components["parameters"]["Tail"];
                /** @description Number of lines to return from the beginning of the file */
                head?: components["parameters"]["Head"];
                /** @description Line number to start reading from (1-based) */
                offset?: components["parameters"]["Offset"];
                /** @description Maximum number of lines to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Log"];
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    downloadDAGRunLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Log file content */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunOutputs: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved outputs. Returns the collected outputs with metadata. If the DAG-run completed but captured no outputs, returns an empty outputs object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DAGRunOutputs"];
                };
            };
            /** @description DAG-run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    retryDAGRun: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    dagRunId: components["schemas"]["DAGRunId"] & unknown;
                    /** @description Optional. If provided, only this step will be retried. */
                    stepName?: string;
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    terminateDAGRun: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunStepLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Number of lines to return from the end of the file */
                tail?: components["parameters"]["Tail"];
                /** @description Number of lines to return from the beginning of the file */
                head?: components["parameters"]["Head"];
                /** @description Line number to start reading from (1-based) */
                offset?: components["parameters"]["Offset"];
                /** @description Maximum number of lines to return */
                limit?: components["parameters"]["Limit"];
                /** @description Whether to return stdout or stderr logs */
                stream?: components["parameters"]["Stream"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Log"];
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    downloadDAGRunStepLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Whether to return stdout or stderr logs */
                stream?: components["parameters"]["Stream"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Log file content */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGRunStepMessages: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Chat messages retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChatMessagesResponse"];
                };
            };
            /** @description DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDAGRunStepStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    status: components["schemas"]["NodeStatus"];
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAGRun or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    approveDAGRunStep: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ApproveStepRequest"];
            };
        };
        responses: {
            /** @description Step approved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApproveStepResponse"];
                };
            };
            /** @description Step is not in Waiting status or required inputs missing */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    rejectDAGRunStep: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RejectStepRequest"];
            };
        };
        responses: {
            /** @description Step rejected successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RejectStepResponse"];
                };
            };
            /** @description Step is not in Waiting status */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRunDetails: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to retrieve details for */
                subDAGRunId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        dagRunDetails: components["schemas"]["DAGRunDetails"];
                    };
                };
            };
            /** @description Sub DAG-run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRunSpec: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to retrieve the spec for */
                subDAGRunId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Sub-DAG specification retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description YAML specification of the sub-DAG */
                        spec: string;
                    };
                };
            };
            /** @description Sub-DAG run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRunLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Number of lines to return from the end of the file */
                tail?: components["parameters"]["Tail"];
                /** @description Number of lines to return from the beginning of the file */
                head?: components["parameters"]["Head"];
                /** @description Line number to start reading from (1-based) */
                offset?: components["parameters"]["Offset"];
                /** @description Maximum number of lines to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to retrieve the log for */
                subDAGRunId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Log"];
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    downloadSubDAGRunLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to download the log for */
                subDAGRunId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Log file content */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRunStepLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Number of lines to return from the end of the file */
                tail?: components["parameters"]["Tail"];
                /** @description Number of lines to return from the beginning of the file */
                head?: components["parameters"]["Head"];
                /** @description Line number to start reading from (1-based) */
                offset?: components["parameters"]["Offset"];
                /** @description Maximum number of lines to return */
                limit?: components["parameters"]["Limit"];
                /** @description Whether to return stdout or stderr logs */
                stream?: components["parameters"]["Stream"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to retrieve the log for */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Log"];
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    downloadSubDAGRunStepLog: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Whether to return stdout or stderr logs */
                stream?: components["parameters"]["Stream"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to download the step log for */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Log file content */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Log file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSubDAGRunStepMessages: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Chat messages retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChatMessagesResponse"];
                };
            };
            /** @description Sub DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateSubDAGRunStepStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run to update the step status for */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    status: components["schemas"]["NodeStatus"];
                };
            };
        };
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAGRun or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    approveSubDAGRunStep: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run containing the step to approve */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ApproveStepRequest"];
            };
        };
        responses: {
            /** @description Step approved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApproveStepResponse"];
                };
            };
            /** @description Step is not in Waiting status or required inputs missing */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Sub DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    rejectSubDAGRunStep: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description name of the DAG */
                name: components["parameters"]["DAGName"];
                /** @description ID of the DAG-run or 'latest' to get the most recent DAG-run */
                dagRunId: components["parameters"]["DAGRunId"];
                /** @description ID of the sub DAG-run containing the step to reject */
                subDAGRunId: string;
                /** @description name of the step */
                stepName: components["parameters"]["StepName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RejectStepRequest"];
            };
        };
        responses: {
            /** @description Step rejected successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RejectStepResponse"];
                };
            };
            /** @description Step is not in Waiting status */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Sub DAG-run or step not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listQueues: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueuesResponse"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listQueueItems: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description page number of items to fetch (default is 1) */
                page?: components["parameters"]["Page"];
                /** @description number of items per page (default is 30, max is 100) */
                perPage?: components["parameters"]["PerPage"];
                /** @description Item type to fetch */
                type?: PathsQueuesNameItemsGetParametersQueryType;
            };
            header?: never;
            path: {
                /** @description Queue name */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueueItemsResponse"];
                };
            };
            /** @description Queue not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getResourceHistory: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Duration of history to retrieve (e.g., 30m, 1h) */
                duration?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceHistory"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSchedulerStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SchedulerStatusResponse"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getCoordinatorStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CoordinatorStatusResponse"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getTunnelStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TunnelStatusResponse"];
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getMetrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Prometheus metrics in text format */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Generic error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    triggerWebhook: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: {
                /** @description Bearer token for webhook authentication (e.g., 'Bearer dagu_wh_...'). Required for authentication but marked optional in schema so the handler can return proper 401 responses. */
                Authorization?: string;
            };
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["WebhookRequest"];
            };
        };
        responses: {
            /** @description DAG run triggered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookResponse"];
                };
            };
            /** @description Invalid request body */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unauthorized - missing or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - webhook disabled or not configured */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description DAG or webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict - DAG run with the specified dagRunId already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listWebhooks: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of webhooks */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookListResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDAGWebhook: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook configuration */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDetails"];
                };
            };
            /** @description No webhook configured for this DAG */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createDAGWebhook: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookCreateResponse"];
                };
            };
            /** @description Webhook already exists for this DAG */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteDAGWebhook: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No webhook configured for this DAG */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    regenerateDAGWebhookToken: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Token regenerated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookCreateResponse"];
                };
            };
            /** @description No webhook configured for this DAG */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    toggleDAGWebhook: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description the name of the DAG file */
                fileName: components["parameters"]["DAGFileName"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookToggleRequest"];
            };
        };
        responses: {
            /** @description Webhook toggled successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDetails"];
                };
            };
            /** @description No webhook configured for this DAG */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listAuditLogs: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
                /** @description Filter by audit category (e.g., terminal, user, dag) */
                category?: string;
                /** @description Filter by user ID */
                userId?: string;
                /** @description Filter entries after this time (ISO 8601 format) */
                startTime?: string;
                /** @description Filter entries before this time (ISO 8601 format) */
                endTime?: string;
                /** @description Maximum number of entries to return (default 100) */
                limit?: number;
                /** @description Number of entries to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of audit log entries */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogsResponse"];
                };
            };
            /** @description Not authenticated */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin role */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSyncStatus: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Sync status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncStatusResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    syncPull: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Pull completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncResultResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    syncPublishAll: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SyncPublishAllRequest"];
            };
        };
        responses: {
            /** @description Publish completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncResultResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    syncTestConnection: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Connection test result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConnectionTestResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSyncConfig: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Configuration retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConfigResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateSyncConfig: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SyncConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Configuration updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConfigResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSyncDAGDiff: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description The DAG name (file name without extension) */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Diff retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncDAGDiffResponse"];
                };
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    publishDag: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description The DAG name (file name without extension) */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SyncPublishRequest"];
            };
        };
        responses: {
            /** @description DAG published successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncResultResponse"];
                };
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict detected */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConflictResponse"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    discardDagChanges: {
        parameters: {
            query?: {
                /** @description name of the remote node */
                remoteNode?: components["parameters"]["RemoteNode"];
            };
            header?: never;
            path: {
                /** @description The DAG name (file name without extension) */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Changes discarded successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessResponse"];
                };
            };
            /** @description DAG not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
export enum PathsDagsGetParametersQuerySort {
    name = "name",
    nextRun = "nextRun"
}
export enum PathsDagsGetParametersQueryOrder {
    asc = "asc",
    desc = "desc"
}
export enum PathsQueuesNameItemsGetParametersQueryType {
    running = "running",
    queued = "queued"
}
export enum ChatMessageRole {
    system = "system",
    user = "user",
    assistant = "assistant",
    tool = "tool"
}
export enum ErrorCode {
    forbidden = "forbidden",
    bad_request = "bad_request",
    not_found = "not_found",
    internal_error = "internal_error",
    unauthorized = "unauthorized",
    bad_gateway = "bad_gateway",
    remote_node_error = "remote_node_error",
    max_run_reached = "max_run_reached",
    not_running = "not_running",
    already_exists = "already_exists",
    auth_unauthorized = "auth.unauthorized",
    auth_token_invalid = "auth.token_invalid",
    auth_forbidden = "auth.forbidden",
    timeout = "timeout"
}
export enum Stream {
    stdout = "stdout",
    stderr = "stderr"
}
export enum HealthResponseStatus {
    healthy = "healthy",
    unhealthy = "unhealthy"
}
export enum Status {
    NotStarted = 0,
    Running = 1,
    Failed = 2,
    Aborted = 3,
    Success = 4,
    Queued = 5,
    PartialSuccess = 6,
    Waiting = 7,
    Rejected = 8
}
export enum StatusLabel {
    not_started = "not_started",
    running = "running",
    failed = "failed",
    aborted = "aborted",
    succeeded = "succeeded",
    queued = "queued",
    partially_succeeded = "partially_succeeded",
    waiting = "waiting",
    rejected = "rejected"
}
export enum TriggerType {
    unknown = "unknown",
    scheduler = "scheduler",
    manual = "manual",
    webhook = "webhook",
    subdag = "subdag"
}
export enum NodeStatus {
    NotStarted = 0,
    Running = 1,
    Failed = 2,
    Aborted = 3,
    Success = 4,
    Skipped = 5,
    PartialSuccess = 6,
    Waiting = 7,
    Rejected = 8
}
export enum NodeStatusLabel {
    not_started = "not_started",
    running = "running",
    failed = "failed",
    aborted = "aborted",
    succeeded = "succeeded",
    skipped = "skipped",
    partially_succeeded = "partially_succeeded",
    waiting = "waiting",
    rejected = "rejected"
}
export enum SchedulerInstanceStatus {
    active = "active",
    inactive = "inactive",
    unknown = "unknown"
}
export enum CoordinatorInstanceStatus {
    active = "active",
    inactive = "inactive",
    unknown = "unknown"
}
export enum TunnelStatusResponseProvider {
    tailscale = "tailscale"
}
export enum TunnelStatusResponseStatus {
    disabled = "disabled",
    connecting = "connecting",
    connected = "connected",
    reconnecting = "reconnecting",
    error = "error"
}
export enum WorkerHealthStatus {
    healthy = "healthy",
    warning = "warning",
    unhealthy = "unhealthy"
}
export enum RepeatMode {
    While = "while",
    Until = "until"
}
export enum QueueType {
    global = "global",
    dag_based = "dag-based"
}
export enum UserRole {
    admin = "admin",
    manager = "manager",
    operator = "operator",
    viewer = "viewer"
}
export enum UserAuthProvider {
    builtin = "builtin",
    oidc = "oidc"
}
export enum SyncStatus {
    synced = "synced",
    modified = "modified",
    untracked = "untracked",
    conflict = "conflict"
}
export enum SyncSummary {
    synced = "synced",
    pending = "pending",
    conflict = "conflict",
    error = "error"
}
export enum SyncAuthConfigType {
    token = "token",
    ssh = "ssh"
}
